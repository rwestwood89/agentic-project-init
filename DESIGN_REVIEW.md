[1;33m  â†’ Generating: Design review (using opus)[0m
Now I have a comprehensive understanding of the existing project. The critical issue is clear: **the `DESIGN_v1.md` file contains only a summary/outline of the design, not the actual design document**. The design was apparently generated by an AI but never persisted.

Let me now deliver the review based on what's available.

---

# Design Review

## Preliminary Finding: DESIGN DOCUMENT IS MISSING

**The file `DESIGN_v1.md` contains only a narrative summary of what a design document would cover â€” not the actual design document.** The file ends with "Shall I write the file to `.project/concepts/dashboard-design.md`?" â€” meaning the design was generated in a conversation but never written to disk.

What exists is essentially a **table of contents with prose descriptions of seven sections**. No actual schemas, algorithms, CLI signatures, HTML wireframes, data flow diagrams, or phasing details are present in the file. The concept document (`.project/concepts/project-dashboard-and-management-upgrade.md`) is thorough and well-structured, but the design document that would translate it into implementable specifications was never saved.

**This means I am reviewing a design summary against a concept document.** I will evaluate what's described, but many "Concerns" and "Fail" ratings below stem from the fundamental absence of specifics.

---

## Dimensional Assessment

### 1. Concept Compliance
**Assessment:** Concerns

**Findings:**
- The summary claims coverage of all concept areas (registry, lifecycle scripts, dashboard, frontmatter, reconciliation), but since the actual schemas, algorithms, and interfaces are missing from the file, **compliance cannot be verified**.
- The summary mentions a `create-epic` script (Section 3), but the concept explicitly puts epic creation/management scripts **out of scope** (Concept: "Out of Scope" section). This is either a concept violation or a deliberate design decision that contradicts the concept, but there's no rationale documented.
- US-4 (Dashboard freshness via file watcher) is referenced in the summary (Section 3: `watch-project`), but without the actual implementation details, it's unclear whether the design handles debouncing, ignored paths, or the fallback manual-trigger requirement.
- US-7 (click-to-copy) appears to be covered in the dashboard section but needs verification in the actual HTML wireframe (Appendix C).
- US-13 (non-conforming items invisible) is a robustness requirement â€” the summary doesn't mention how the reconciliation or dashboard handles non-registry items gracefully.

**Recommendations:**
1. Write the actual design document to disk so it can be reviewed.
2. Resolve the `create-epic` contradiction: either add epic scripts to concept scope or remove from design.
3. Ensure each user story has a traceable design element.

### 2. Abstraction Quality
**Assessment:** Concerns

**Findings:**
- The described architecture (Section 3) splits into two logical groups â€” lifecycle scripts and dashboard tools â€” which is clean and mirrors the concept's decomposition.
- Seven scripts (`create-item`, `create-epic`, `move-item`, `update-status`, `reconcile`, `generate-dashboard`, `watch-project`) is a reasonable count, but `update-status` may be doing too much: it handles YAML frontmatter updates, registry updates, and phase count changes for different artifact types. This is potentially a "God script" risk.
- The concept defines clear source-of-truth boundaries (registry owns structure, frontmatter owns per-artifact status). The design summary mentions this but doesn't describe how scripts enforce it â€” e.g., what happens when `update-status` changes a frontmatter status field that implies a stage change? Does it update the registry too, or is that `move-item`'s job?
- The relationship between `update-status` and `move-item` is ambiguous. Concept US-10 says "update status" should "ensure the registry reflects the change." But concept Key Concept #4 ("Update status") says it "updates the registry if the change is stage-relevant." What determines stage-relevance? This boundary is critical and needs explicit specification.

**Recommendations:**
1. Clarify the `update-status` vs `move-item` boundary with concrete examples.
2. Consider whether `update-status` should be split into `update-frontmatter` (single artifact) and `advance-stage` (structural change).
3. Document the exact triggers that cause registry writes vs. frontmatter-only writes.

### 3. Duplication Avoidance
**Assessment:** Concerns

**Findings:**
- The design inherently introduces **dual-write** between `registry.json` and YAML frontmatter. The concept acknowledges this and designates reconciliation as the safety net. However, every lifecycle script must now maintain consistency across both stores on every operation. This is a maintenance burden that will grow.
- Item titles appear in at least three places: registry.json, YAML frontmatter, and potentially the markdown heading. The design summary doesn't address which is authoritative for display.
- The concept specifies that `CHANGELOG.md` is updated on item close (US-9). The existing `_my_project_manage close` command already updates CHANGELOG.md. The design needs to clarify whether the script replaces or supplements the command's changelog logic â€” otherwise both will write to CHANGELOG.md.

**Recommendations:**
1. Explicitly designate title authoritativeness: registry title is derived from frontmatter at reconciliation, or vice versa.
2. Ensure the `move-item` script fully owns CHANGELOG.md writes, and the `_my_project_manage close` command delegates entirely to the script.
3. Consider whether the dashboard should read titles from registry only (simpler) or cross-reference frontmatter (richer but slower).

### 4. Data Structure Clarity
**Assessment:** Fail

**Findings:**
- The **actual data schemas are not present in the design file**. The summary references "TypeScript-style schemas for `registry.json` and YAML frontmatter" (Section 2) but none are in the document.
- The concept provides a rough `registry.json` shape, but the design should have refined it. Key missing details:
  - What does an epic entry contain beyond `title` and `status`? Does it store `items: [...]` or do you query items by `epic` field?
  - What are the valid values for `stage`? The concept uses `backlog`, `active`, `completed` but the design should enumerate them as a formal enum.
  - What does `path` in an item entry contain? Relative path? Absolute? Relative to `.project/`?
  - For backlog items (no folder or artifacts yet): `path` is null? Empty string? Absent?
- The YAML frontmatter schema is listed in the concept but described as "will be refined during spec phase." The design should have refined it. Specifically:
  - Is `owner` a free-text string or a constrained value?
  - The `status` field uses `draft`, `in-progress`, `complete` â€” but the registry uses `stage` with `backlog`, `active`, `completed`. These are different dimensions but could easily be confused.
  - `phases_total` and `phases_complete` are plan-only fields. What value do they take if the plan hasn't started implementation? 0/0? null? Absent?

**Recommendations:**
1. Write the actual design with complete, typed schemas for both registry.json and YAML frontmatter.
2. Enumerate all valid values for `status`, `stage`, `type`, and other constrained fields.
3. Define the `path` format and null-handling for backlog items.
4. Address the `status` (frontmatter) vs. `stage` (registry) naming collision explicitly.

### 5. Interface Completeness
**Assessment:** Fail

**Findings:**
- The summary claims "Full CLI signatures for all seven scripts" (Section 5) but **none are present in the file**.
- Without CLI signatures, it's impossible to evaluate:
  - Required vs. optional arguments for each script
  - Output format (JSON? plain text? exit codes?)
  - Error handling (what happens when you `move-item` an already-completed item?)
  - Whether scripts are idempotent (can you safely re-run `update-status` with the same status?)
- The "agentic command integration pattern" (Section 5) is described only by label. The existing commands (`_my_spec`, `_my_project_manage`) have rich, detailed patterns (multi-stage workflows, user confirmation gates, specific file reads). The design must specify exactly where in each command's flow the lifecycle script calls are inserted.
- The concept mentions `.claude/settings.local.json` needs permissions for new scripts. The design should specify exact permission entries since this file currently doesn't exist.

**Recommendations:**
1. Write complete CLI signatures with argument types, defaults, output format, and exit codes.
2. Document error cases: invalid code, nonexistent item, wrong stage for operation, missing artifact file.
3. Map each lifecycle script call to the exact step in each agentic command where it would be invoked.
4. Specify the `settings.local.json` permission entries.

### 6. Implementability
**Assessment:** Concerns

**Findings:**
- The described phasing (Section 7) â€” Foundation â†’ Dashboard â†’ Integration â€” matches the concept's decomposition guidance and is reasonable. Phase 1 (registry + scripts) is genuinely standalone.
- **Dependency on Python YAML library:** The concept notes "Python 3 available" as a prerequisite, but doesn't specify whether `pyyaml` is available. The scripts will need YAML parsing. If `pyyaml` is not installed, Phase 1 is blocked. The design should specify whether it uses `pyyaml`, a stdlib-only regex approach, or bundles a dependency.
- **Atomic writes to `registry.json`:** The concept mentions atomicity. The design summary mentions it (Section 6: "atomic writes"). But implementing atomic file writes in Python requires either `tempfile + os.rename` or an external library. The design should specify the mechanism.
- **File watcher implementation:** The design mentions a file watcher but doesn't specify the technology. Python's `watchdog` library, `inotifywait`, or `fswatch`? Each has different installation requirements and cross-platform behavior. This is an implementability risk.
- **`create-epic` in design but out-of-scope in concept:** As noted in Dimension 1, this creates an implementation ambiguity. An implementer would not know whether to build this script.
- **HTML generation approach:** The design mentions dashboard generation but doesn't specify whether it uses string templates, Jinja2, or raw string concatenation. For a full Kanban board with tooltips and click-to-copy, the template complexity is non-trivial.
- **Existing command modification risk:** The commands `_my_spec` and `_my_project_manage` are complex multi-stage workflows (as seen in the exploration). Modifying them to call scripts requires careful integration. The design should identify exact insertion points and fallback behavior if scripts aren't available (e.g., freshly cloned repo without Python deps).

**Recommendations:**
1. Specify Python dependencies explicitly (pyyaml, watchdog, or alternatives).
2. Define the atomic write mechanism.
3. Choose and document the file watcher technology.
4. Resolve the `create-epic` scope question.
5. Specify the HTML templating approach.
6. Address graceful degradation: what happens if scripts aren't installed/available when commands run?

---

## Issues by Severity

### Critical (Must address before implementation)

1. **Design document not written to disk** â€” The actual design with schemas, algorithms, CLI signatures, and wireframes was never saved. Only a summary exists. No implementation can proceed from a summary. â€” *All Dimensions*
2. **No data schemas defined** â€” Registry.json structure, YAML frontmatter fields, valid enums, and null-handling are all unspecified. â€” *Dimension 4*
3. **No CLI interfaces defined** â€” Script arguments, output formats, exit codes, and error handling are all unspecified. â€” *Dimension 5*

### Major (Should address)

4. **`create-epic` scope contradiction** â€” Design includes `create-epic` script; concept explicitly excludes epic management scripts. â€” *Dimensions 1, 6*
5. **`update-status` vs `move-item` boundary unclear** â€” When does a status change trigger a stage transition? Who's responsible? â€” *Dimension 2*
6. **`status` vs `stage` naming collision** â€” Frontmatter uses `status` (draft/in-progress/complete), registry uses `stage` (backlog/active/completed). These are distinct concepts with confusingly similar names. â€” *Dimension 4*
7. **Python dependency chain unspecified** â€” pyyaml, watchdog, Jinja2 availability unknown; no fallback plan. â€” *Dimension 6*
8. **CHANGELOG.md dual-write risk** â€” Both existing commands and new scripts may write to CHANGELOG.md. â€” *Dimension 3*

### Minor (Consider addressing)

9. **Title stored in multiple locations** â€” Registry, frontmatter, and markdown heading could drift. â€” *Dimension 3*
10. **Backlog item `path` handling** â€” Backlog items have no folder; `path` field semantics undefined. â€” *Dimension 4*
11. **HTML template approach unspecified** â€” Kanban board with tooltips and click-to-copy needs a real templating decision. â€” *Dimension 6*
12. **File watcher technology unspecified** â€” inotifywait vs watchdog vs fswatch affects installation and portability. â€” *Dimension 6*

---

## Specific Recommendations

1. **Write the actual design document.** The most critical action. Persist the design with full schemas, algorithms, CLI signatures, and the HTML wireframe. Until this happens, no dimension can receive a "Pass" rating.

2. **Resolve the `create-epic` scope question.** Either update the concept to include epic management scripts (with rationale), or remove `create-epic` from the design. Don't leave contradictions for implementers.

3. **Define complete, typed schemas.** For `registry.json`: specify every field, its type, valid values, and nullability. For YAML frontmatter: distinguish required from optional fields per artifact type. Rename `stage` to something distinct from `status` (e.g., `lifecycle_stage` or `column`) to avoid confusion.

4. **Write CLI signatures as executable specifications.** For each script: `usage: script-name <required-arg> [optional-arg]`, expected stdout format (prefer JSON for machine-readable output), stderr for errors, exit codes (0=success, 1=input error, 2=state error, etc.).

5. **Map script calls into existing command workflows.** For each of `_my_spec`, `_my_design`, `_my_plan`, `_my_implement`, `_my_project_manage`: identify the exact stage number and step where the script call replaces current behavior. The commands are complex â€” this mapping prevents integration bugs.

6. **Specify dependency management.** List required Python packages. Decide: vendored, pip-installed, or stdlib-only? If pyyaml is required, how is it installed? Add a `requirements.txt` or equivalent.

---

**Overall: Rework**

The design summary describes a sound architecture that aligns well with the concept, but the actual design document was never persisted. What exists is a narrative outline â€” not an implementable specification. The schemas, interfaces, algorithms, and integration details that would make this buildable are all absent from the file. The concept itself is strong and well-thought-out; the design just needs to be properly written and saved before it can be approved.
